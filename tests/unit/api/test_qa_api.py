# tests/unit/api/test_qa_api.py
import pytest
from fastapi.testclient import TestClient
from unittest.mock import patch, AsyncMock, MagicMock

# To test the router, we create a minimal FastAPI app instance that only includes this router.
# This avoids needing the full application setup for unit tests.
from fastapi import FastAPI
from app.api.v1.routers.qa import router as qa_router_module # Import your qa router
from app.api.v1.schemas.qa_schemas import QAInput, QAResponse # Import your schemas

# Create a minimal app for testing this specific router
# The prefix should match how it's included in your main app for route resolution.
# In app.main.py, it's included with prefix=f"{settings.API_V1_STR}/qa"
# For simplicity in unit test, let's assume API_V1_STR is "/api/v1"
# Or, you can import settings here too. For now, hardcoding for clarity.
API_PREFIX = "/api/v1/qa" 

test_app = FastAPI()
test_app.include_router(qa_router_module, prefix=API_PREFIX)

client = TestClient(test_app)

# Sample valid input data based on QAInput schema
sample_valid_input_dict = {
    "question": "What was the revenue in 2008?",
    "pre_text": ["Some text before the table."],
    "post_text": ["Some text after the table."],
    "table_ori": [
        ["", "2008", "2007"],
        ["Revenue", "$1000", "$900"],
        ["Profit", "$100", "$90"]
    ],
    "item_id": "test_item_001"
}

@pytest.fixture
def mock_placeholder_qa_service():
    # This mock will simulate the PlaceholderQAService (or later, the real QAService)
    mock_service = AsyncMock() # Use AsyncMock for async methods
    # Configure the mock to return a QAResponse-like object (or a dict that can be parsed into it)
    mock_service.process_single_entry_query.return_value = QAResponse(
        answer="Mocked successful answer from service!",
        explanation="This answer was generated by a mocked service for testing.",
        tool_calls_log=[]
    )
    return mock_service

def test_process_query_success(mock_placeholder_qa_service: AsyncMock):
    """Test successful processing of a valid query with mocked service."""
    # The key is to patch the dependency provider used in the router.
    # In qa.py, it's `get_placeholder_qa_service`.
    with patch("app.api.v1.routers.qa.get_placeholder_qa_service", return_value=mock_placeholder_qa_service):
        response = client.post(f"{API_PREFIX}/process-query", json=sample_valid_input_dict)
        
    assert response.status_code == 200
    response_data = response.json()
    assert response_data["answer"] == "Mocked successful answer from service!"
    assert "explanation" in response_data
    
    # Check if the mock service method was called correctly
    mock_placeholder_qa_service.process_single_entry_query.assert_called_once()
    # Inspect the arguments it was called with (it should be a QAInput instance)
    called_with_arg = mock_placeholder_qa_service.process_single_entry_query.call_args[0][0]
    assert isinstance(called_with_arg, QAInput)
    assert called_with_arg.question == sample_valid_input_dict["question"]
    assert called_with_arg.item_id == sample_valid_input_dict["item_id"]

def test_process_query_missing_required_field_question():
    """Test request with a missing required field ('question')."""
    invalid_input = sample_valid_input_dict.copy()
    del invalid_input["question"] 
    
    response = client.post(f"{API_PREFIX}/process-query", json=invalid_input)
    assert response.status_code == 422 # Unprocessable Entity for Pydantic validation errors
    response_data = response.json()
    assert "detail" in response_data
    # Check for specific error related to 'question' field
    assert any("question" in error.get("loc", []) and error.get("type") == "missing" for error in response_data["detail"])

def test_process_query_missing_required_field_table_ori():
    """Test request with a missing required field ('table_ori')."""
    invalid_input = sample_valid_input_dict.copy()
    del invalid_input["table_ori"]
    
    response = client.post(f"{API_PREFIX}/process-query", json=invalid_input)
    assert response.status_code == 422
    response_data = response.json()
    assert "detail" in response_data
    assert any("table_ori" in error.get("loc", []) and error.get("type") == "missing" for error in response_data["detail"])


def test_process_query_invalid_table_ori_type():
    """Test request with an invalid type for 'table_ori' (e.g., string instead of list of lists)."""
    invalid_input = sample_valid_input_dict.copy()
    invalid_input["table_ori"] = "this is not a list of lists"
    
    response = client.post(f"{API_PREFIX}/process-query", json=invalid_input)
    assert response.status_code == 422
    response_data = response.json()
    assert "detail" in response_data
    error_detail = next((e for e in response_data["detail"] if "table_ori" in e.get("loc", [])), None)
    assert error_detail is not None
    # Pydantic's error type for list of lists might be 'list_type' or more specific based on nested validation
    assert "list" in error_detail.get("type", "").lower() or "input should be a valid list" in error_detail.get("msg", "").lower()


def test_process_query_service_raises_http_exception(mock_placeholder_qa_service: AsyncMock):
    """Test how the endpoint handles an HTTPException raised by the service (or router itself)."""
    # Configure the mock service to raise an HTTPException
    mock_placeholder_qa_service.process_single_entry_query.side_effect = HTTPException(
        status_code=400, detail="Simulated bad request from service"
    )

    with patch("app.api.v1.routers.qa.get_placeholder_qa_service", return_value=mock_placeholder_qa_service):
        response = client.post(f"{API_PREFIX}/process-query", json=sample_valid_input_dict)
        
    assert response.status_code == 400
    response_data = response.json()
    assert response_data["detail"] == "Simulated bad request from service"

def test_process_query_service_raises_unexpected_exception(mock_placeholder_qa_service: AsyncMock):
    """Test how the endpoint handles an unexpected Python exception from the service layer."""
    # Configure the mock service to raise a generic Exception
    mock_placeholder_qa_service.process_single_entry_query.side_effect = Exception("Unexpected internal service error!")

    with patch("app.api.v1.routers.qa.get_placeholder_qa_service", return_value=mock_placeholder_qa_service):
        response = client.post(f"{API_PREFIX}/process-query", json=sample_valid_input_dict)
        
    assert response.status_code == 500 # Should be caught and converted to 500
    response_data = response.json()
    assert "An unexpected error occurred: Unexpected internal service error!" in response_data["detail"]

def test_root_endpoint():
    """Test the root endpoint of the main app if you want to include it here for completeness,
       though typically it might be in a separate test_main.py."""
    # This requires TestClient to be initialized with the main app from app.main
    from app.main import app as main_fastapi_app 
    main_client = TestClient(main_fastapi_app)
    response = main_client.get("/")
    assert response.status_code == 200
    assert "Welcome to the Financial AI Agent!" in response.json()["message"] # Adjust to your project name from settings

